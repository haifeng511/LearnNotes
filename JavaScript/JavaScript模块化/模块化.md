# 模块化

[TOC]

## 1. 概念

**什么是模块化？**

将一个复杂的程序依据一定的规范封装成几个块（文件），并进行组合 在一起

块的内部数据/实现 是私有的，只是向外暴露了一些接口（方法）与外部其他模块进行通信

**为什么要模块化？**

降低复杂度，提高解耦性，

**模块化的好处?**

避免命名冲突

更好地分离，按需加载

更高的复用性

更好的可维护性



## 2. 模块化模式进化史

### 2.1 全局function模式

将不同的功能封装成不同的函数，这样全局变量容易被污染，可能产生命名冲突

``` javascript
// 全局函数模式定义
// module1.js
let msg = 'module1'
function foo(){
    console.log('foo',msg)
}
function bar(){
    console.log('bar',msg)
}

// 全局模式使用
// 另一个引用了module1.js的html文件或者js文件
foo();
bar();
// 下面会造成打印值不一样
msg = 'msg';
foo();
```



### 2.2 namespace模式

简单对象封装，只是减少了全局变量的数量，本质上是对象，还是能进行修改，不安全

```javascript
// namespace 命名空间模式
// module2.js
let obj = {
	msg:'module2',
	foo(){
		console.log('foo',this.msg)
	}
};

// namespace使用
// 另一个引用了module2.js的html文件或者js文件
obj.foo();
// 下面会造成打印值变化
obj.msg = 'NBA';
obj.foo();

```

### 2.3 IIFE模式

匿名函数自调用（闭包）

```javascript
// IIFE模式:匿名函数自调用
// module3.js
(function(window){
    let msg = 'module3'
    function foo(){
        console.log('foo',msg)
    }
    //下方如果不写是不能访问的
    window.module3 = {
        foo
    }
})(window)

// IIFE模式使用
// 另一个引用了module3.js的html文件或者js文件
module3.foo();
```

### 2.4 IIFE增强模式：引入依赖

这是现代模块实现的基石

```javascript
// IIFE模式增强：引入依赖
// module4.js
(function(window,$){ // 这里是形参
    let msg = 'module4'
    function foo(){
        console.log('foo',msg)
    }
    window.module4 = foo;
    $('body').css('background','red')
})(window,jQuery)// 传入window和jQuery

// IIFE模式增强使用
// 另一个引用了module4.js的html文件或者js文件
// 在引用modules4.js之前引入jQuery
module4();
```

哪怕上述方案是比较好的了，但是也存在一些问题

一个页面需要引入多个js文件，请求过多、依赖模糊、难以维护

通过现代模块化编码和项目构建来解决以上问题

## 3. 模块化规范

### 3.1 CommonJs

node是使用CommonJs

**特点：**

每个js文件都可以当作一个模块

在服务器端，模块的加载是运行时同步加载的（有可能会堵塞）

在浏览器端，模块需要提前编译打包处理（有可能会出现页面空白）

**基本语法：**

暴露模块：module.exports =value(value是数据)

​					exports.xxx = value

暴露的本质是exports对象

引入模块：require(xxx)

​					第三方模块，xxx是模块名

​					自定义模块，xxx是模块文件路径

**实现：**

在服务器端使用node.js实现

在浏览器端使用Browserify进行编译和打包，最后页面引用的是打包之后的js文件

### 3.2 AMD

异步模块定义

专门用于浏览器端，模块的加载是异步的

**（1）定义暴露模块**

```javascript
//定义没有依赖的模块：
define(function(){
	return 模块
})

// 定义有依赖的模块：
define(['module1','module2'],function(m1,m2){
	return 模块
})
```

**（2）引入使用模块**

```javascript
// 引入使用模块
require(['module1','module2'],function(m1,m2){
	// 使用m1,m2
})
```



### 3.3 CMD

通用模块定义

专门用于浏览器端，模块的加载是异步的，模块使用时才会加载执行

实现需要使用seajs.js

**（1）定义暴露模块**

```javascript
//定义没有依赖的模块：
define(function(require,exports,module){
	module.exports =value(value是数据)
    exports.xxx = value
})

// 定义有依赖的模块：
define(function(require,exports,module){
    // 引入同步依赖模块
    let module2 = require('./module2');
    // 引入异步依赖模块
    require.async('./module3',funcion(m3){
                  
                  })
	// 暴露模块
    exports.xxx = value
})
```

**（2）引入使用模块**

```javascript
// 引入使用模块
define(function(require){
    let m1 = require('./module1');
    let m4 = require('./module4');
    m1.show();
    m4.show();
})
```



### 3.4 ES6

依赖模块需要编译打包处理

导出模块export

引入模块import





