# 模块化

[TOC]

## 1. 概念

**什么是模块化？**

将一个复杂的程序依据一定的规范封装成几个块（文件），并进行组合 在一起

块的内部数据/实现 是私有的，只是向外暴露了一些接口（方法）与外部其他模块进行通信

**为什么要模块化？**

降低复杂度，提高解耦性，

**模块化的好处?**

避免命名冲突

更好地分离，按需加载

更高的复用性

更好的可维护性



## 2. 模块化模式进化史

### 2.1 全局function模式

将不同的功能封装成不同的函数，这样全局变量容易被污染，可能产生命名冲突

``` javascript
// 全局函数模式定义
// module1.js
let msg = 'module1'
function foo(){
    console.log('foo',msg)
}
function bar(){
    console.log('bar',msg)
}

// 全局模式使用
// 另一个引用了module1.js的html文件或者js文件
foo();
bar();
// 下面会造成打印值不一样
msg = 'msg';
foo();
```



### 2.2 namespace模式

简单对象封装，只是减少了全局变量的数量，本质上是对象，还是能进行修改，不安全

```javascript
// namespace 命名空间模式
// module2.js
let obj = {
	msg:'module2',
	foo(){
		console.log('foo',this.msg)
	}
};

// namespace使用
// 另一个引用了module2.js的html文件或者js文件
obj.foo();
// 下面会造成打印值变化
obj.msg = 'NBA';
obj.foo();

```

### 2.3 IIFE模式

匿名函数自调用（闭包）

```javascript
// IIFE模式:匿名函数自调用
// module3.js
(function(window){
    let msg = 'module3'
    function foo(){
        console.log('foo',msg)
    }
    //下方如果不写是不能访问的
    window.module3 = {
        foo
    }
})(window)

// IIFE模式使用
// 另一个引用了module3.js的html文件或者js文件
module3.foo();
```

### 2.4 IIFE增强模式：引入依赖

这是现代模块实现的基石

```javascript
// IIFE模式增强：引入依赖
// module4.js
(function(window,$){ // 这里是形参
    let msg = 'module4'
    function foo(){
        console.log('foo',msg)
    }
    window.module4 = foo;
    $('body').css('background','red')
})(window,jQuery)// 传入window和jQuery

// IIFE模式增强使用
// 另一个引用了module4.js的html文件或者js文件
// 在引用modules4.js之前引入jQuery
module4();
```

哪怕上述方案是比较好的了，但是也存在一些问题

一个页面需要引入多个js文件，请求过多、依赖模糊、难以维护

通过现代模块化编码和项目构建来解决以上问题

## 3. 模块化规范

### 3.1 CommonJs

node是使用CommonJs

**特点：**

每个js文件都可以当作一个模块

在服务器端，模块的加载是运行时同步加载的（有可能会堵塞）

在浏览器端，模块需要提前编译打包处理（有可能会出现页面空白）

**基本语法：**

**(1）定义暴露模块**

```javascript
/**
 * 使用module.exports = value 定义和暴露
 */
module.exports = {
    m1() {
      console.log('moudle1 m1()')
    }
  }

module.exports = function (){
    console.log('module2 m2()');
}

/**
 * 使用export.xxx = value 定义和暴露
 */

exports.m3 = function (){
    console.log('module3 m3()');
}
```

**(2) 引入模块**

```javascript
/**
 * 使用require(xxx) xxx是路径 引入模块
 */

let module1 = require('./module/module1');
let module2 = require('./module/module2');
let module3 = require('./module/module3');

module1.m1();
module2();
module3.m3()
```



**（3）实现：**

在服务器端使用node.js实现

直接使用node main.js 可得到结果

在浏览器端使用Browserify进行编译和打包，最后页面引用的是打包之后的js文件

1.需要下载Browserify

npm install browserify -g

2.打包

 browserify main.js -o bundle.js

3.在html中引用打包好的bundle.js文件



### 3.2 AMD

异步模块定义

专门用于浏览器端，模块的加载是异步的

**AMD需要配置和使用requirejs**

下载require.js的地址：https://www.requirejs-cn.cn/docs/download.html#requirejs

**（1）定义暴露模块**

```javascript
//定义没有依赖的模块：
define(function(){
	let msg = 'module1';
    function getMsg(){
        return msg;
    }
    return {getMsg};
})
// 定义有依赖的模块：
define(['module1','jquery'],function(m1,m2){
    let msg = 'module2';
    function getMsg(){
        m2('body').css('background', 'blue')
        console.log('m1:'+ m1.getMsg());
        console.log('m2:'+ msg);
    }
	return {getMsg}
})
```

**（2）引入使用模块**

```javascript
(function () {
    //配置
    requirejs.config({
      //基本路径
      baseUrl: "./",
      //模块标识名与模块路径映射
      paths: {
        'jquery': 'lib/jquery-1.10.1',
        "module1": "module/module1",
        "module2": "module/module2",
      }
    })
    
    //引入使用模块
    requirejs( ['module2'], function(module2) {
        module2.getMsg()
    })
  })()
```

**（3）实现**

在index.html中引用require.js和main.js

```html
<!-- 
        require.js 在加载的时候会检察data-main 属性
        data-main指向的脚本中设置模板加载 选项，然后加载第一个应用模块
     -->
    <script data-main="./main" src="./lib/require.js"></script>
```



### 3.3 CMD

通用模块定义

专门用于浏览器端，模块的加载是异步的，模块使用时才会加载执行

实现需要使用seajs

下载sea.js地址：https://seajs.github.io/seajs/docs/#downloads

**（1）定义暴露模块**

```javascript
//定义没有依赖的模块：
define(function (require, exports, module) {
    //内部变量数据
    let data = 'module1 data'
    //内部函数
    function show() {
      console.log('module1 show() and  the module1 data is ' + data)
    }
  
    //向外暴露
    exports.show = show
  })

define(function (require, exports, module) {
    module.exports = {
      data: 'module2 data'
    }
  })

// 定义有依赖的模块：
define(function (require, exports, module) {
    //引入依赖模块(同步)
    let module2 = require('./module2')
  
    function show() {
      console.log('module3 show() and  the module2 data is ' + module2.data)
    }
  
    exports.show = show
    //引入依赖模块(异步)
    require.async('./module1', function (m1) {
      console.log('异步引入依赖模块1 and  the module1 show is ' + m1.show)
    })
  })
```

**（2）引入使用模块**

```javascript
// 引入使用模块
define(function (require) {
    let m1 = require('./module/module1');
    let m3 = require('./module/module3');
    m1.show();
    console.log('-----------------');
    m3.show();
  });
```

**（3）实现**

在index.html中引入sea.js，使用seajs.use()

```html
    <!--
        使用seajs:
        1. 引入sea.js库
        2. 如何定义导出模块 :
            define()
            exports
            module.exports
        3. 如何依赖模块:
            require()
        4. 如何使用模块:
            seajs.use()
-->
    <script type="text/javascript" src="lib/sea.js"></script>
    <script type="text/javascript">
     seajs.use()
    </script>
```





### 3.4 ES6

依赖模块需要编译打包处理

导出模块export

引入模块import





