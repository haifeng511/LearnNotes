# 模块化

[TOC]

## 1. 概念

**什么是模块化？**

将一个复杂的程序依据一定的规范封装成几个块（文件），并进行组合 在一起

块的内部数据/实现 是私有的，只是向外暴露了一些接口（方法）与外部其他模块进行通信

**为什么要模块化？**

降低复杂度，提高解耦性，

**模块化的好处?**

避免命名冲突

更好地分离，按需加载

更高的复用性

更好的可维护性



## 2. 模块化模式进化史

### 2.1 全局function模式

将不同的功能封装成不同的函数，这样全局变量容易被污染，可能产生命名冲突

``` javascript
// 全局函数模式定义
// module1.js
let msg = 'module1'
function foo(){
    console.log('foo',msg)
}
function bar(){
    console.log('bar',msg)
}

// 全局模式使用
// 另一个引用了module1.js的html文件或者js文件
foo();
bar();
// 下面会造成打印值不一样
msg = 'msg';
foo();
```



### 2.2 namespace模式

简单对象封装，只是减少了全局变量的数量，本质上是对象，还是能进行修改，不安全

```javascript
// namespace 命名空间模式
// module2.js
let obj = {
	msg:'module2',
	foo(){
		console.log('foo',this.msg)
	}
};

// namespace使用
// 另一个引用了module2.js的html文件或者js文件
obj.foo();
// 下面会造成打印值变化
obj.msg = 'NBA';
obj.foo();

```

### 2.3 IIFE模式

匿名函数自调用（闭包）

```javascript
// IIFE模式:匿名函数自调用
// module3.js
(function(window){
    let msg = 'module3'
    function foo(){
        console.log('foo',msg)
    }
    //下方如果不写是不能访问的
    window.module3 = {
        foo
    }
})(window)

// IIFE模式使用
// 另一个引用了module3.js的html文件或者js文件
module3.foo();
```

### 2.4 IIFE增强模式：引入依赖

这是现代模块实现的基石

```javascript
// IIFE模式增强：引入依赖
// module4.js
(function(window,$){ // 这里是形参
    let msg = 'module4'
    function foo(){
        console.log('foo',msg)
    }
    window.module4 = foo;
    $('body').css('background','red')
})(window,jQuery)// 传入window和jQuery

// IIFE模式增强使用
// 另一个引用了module4.js的html文件或者js文件
// 在引用modules4.js之前引入jQuery
module4();
```

哪怕上述方案是比较好的了，但是也存在一些问题

一个页面需要引入多个js文件，请求过多、依赖模糊、难以维护

## 3. 模块化规范

### 3.1 CommonJs **

node是使用CommonJs

**特点：**

每个js文件都可以当作一个模块

在服务器端，模块的加载是运行时同步加载的（有可能会堵塞）

在浏览器端，模块需要提前编译打包处理（有可能会出现页面空白）

**基本语法：**

暴露模块：**module.exports =value**(value是数据)

​					**exports.xxx = value**

暴露的本质是exports对象

注意这里module单词不要写错，exports是带有s的

```javascript
module.exports = {
    m1() {
      console.log('moudle1 m1()')
    }
  }
module.exports = function (){
    console.log('module2 m2()');
}
exports.m3 = function (){
    console.log('module3 m3()');
}
```

引入模块：require(xxx)

​					第三方模块，xxx是模块名

​					自定义模块，xxx是模块文件路径

```javascript
let module1 = require('./module/module1');
let module2 = require('./module/module2');
let module3 = require('./module/module3');

module1.m1();
module2();
module3.m3()
```

**实现：**

在服务器端使用node.js实现

​	node  xxx.js

在浏览器端使用Browserify进行编译和打包，最后页面引用的是打包之后的js文件

​	1.下载browserify

​	npm install browserify -g

​	2.打包处理js文件

​	browserify 原文件目录 -0 生成文件目录  例如：browserify main.js -o bundle.js 

​	3.在index.html中引用bundle.js文件

### 3.2 AMD *

异步模块定义

专门用于浏览器端，模块的加载是异步的

**AMD需要使用require.js，并进行配置**

中文官网下载地址：https://www.requirejs-cn.cn/docs/download.html

**（1）定义暴露模块**

```javascript
//定义没有依赖的模块：
define(function(){
	let msg = 'module1';
    function getMsg(){
        return msg;
    }
    return {getMsg};
})

// 定义有依赖的模块：
define(['module1','jquery'],function(m1,m2){
    let msg = 'module2';
    function getMsg(){
        m2('body').css('background', 'blue')
        console.log('m1:'+ m1.getMsg());
        console.log('m2:'+ msg);
    }
	return {getMsg}
})
```

**（2）引入使用模块**

```javascript
(function () {
    //配置
    requirejs.config({
      //基本路径
      baseUrl: "./",
      //模块标识名与模块路径映射
      paths: {
        'jquery': 'lib/jquery-1.10.1',
        "module1": "module/module1",
        "module2": "module/module2",
      }
    })
    
    //引入使用模块
    requirejs( ['module2'], function(module2) {
        module2.getMsg()
    })
  })()
```

**（3）页面使用模块**

```html
  <!-- 
        require.js 在加载的时候会检察data-main 属性
        data-main指向的脚本中设置模板加载 选项，然后加载第一个应用模块
     -->

    <script data-main="./main" src="./lib/require.js"></script>
```



### 3.3 CMD *

通用模块定义

专门用于浏览器端，模块的加载是异步的，模块使用时才会加载执行

实现需要使用seajs

seajs下载地址：https://seajs.github.io/seajs/docs/#downloads

**（1）定义暴露模块**

```javascript
//定义没有依赖的模块：
define(function(require,exports,module){
	module.exports =value(value是数据)
    exports.xxx = value
})

// 定义有依赖的模块：
define(function(require,exports,module){
    // 引入同步依赖模块
    let module2 = require('./module2');
    // 引入异步依赖模块
    require.async('./module3',funcion(m3){
                  
                  })
	// 暴露模块
    exports.xxx = value
})
```

**（2）引入使用模块**

```javascript
// 引入使用模块
define(function(require){
    let m1 = require('./module1');
    let m4 = require('./module4');
    m1.show();
    m4.show();
})
```



### 3.4 ES6 ***

依赖模块需要编译打包处理

导出模块export

引入模块import





